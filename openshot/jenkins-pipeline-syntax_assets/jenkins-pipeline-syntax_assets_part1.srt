1
00:00:03,420 --> 00:00:08,940
大家好欢迎观看由jenkins中文社区出品的jenkins系列中文教程

2
00:00:09,900 --> 00:00:14,250
本讲我们分享的是jenkins流水线语法的概念

3
00:00:14,521 --> 00:00:15,600
在本次分享中

4
00:00:15,601 --> 00:00:20,370
我们不会涉及到流水线的实际的编写和运行的效果

5
00:00:20,371 --> 00:00:24,990
主要是为了让大家对jenkins的语法有一个整体的认识

6
00:00:24,991 --> 00:00:28,110
然后在后面的章节中会介绍如何去编写

7
00:00:28,110 --> 00:00:34,350
首先，我们要对流水线的语法的文档要很熟悉

8
00:00:34,351 --> 00:00:35,910
那么我这儿给了一个地址

9
00:00:37,475 --> 00:00:43,854
然后，从右侧的目录，我们可以很清晰的看到哪些区域有哪些指令

10
00:00:44,200 --> 00:00:49,025
以及它是串行的还是并行的等等...还有其它的。

11
00:00:49,562 --> 00:00:52,400
ok,首先让我们讲一下流水线是什么?

12
00:00:52,400 --> 00:00:55,590
jenkins流水线采用groovy语法来编写

13
00:00:55,591 --> 00:00:57,960
groovy是一种脚本语言

14
00:00:57,961 --> 00:01:02,760
它这种语言跟Java语言语法非常的类似

15
00:01:02,761 --> 00:01:05,610
大家去网上可以随便搜索一下

16
00:01:06,600 --> 00:01:12,750
因此，在后面如果你发现在编写脚本的时候，不知道该怎么写

17
00:01:13,021 --> 00:01:16,470
或者说不知道有哪些函数和命令可以使用

18
00:01:16,472 --> 00:01:21,025
那你就可以搜索一下groovy它的这方面怎么写

19
00:01:21,375 --> 00:01:27,525
或者说，如果你知道这些在java怎么编写的话，直接用Java的方式写就可以了

20
00:01:27,931 --> 00:01:29,550
当然，可能有些特殊的语法

21
00:01:30,750 --> 00:01:33,750
OK，这是基本的语法层面

22
00:01:35,176 --> 00:01:39,400
大家在说Jenkins流水线的时候，通常也会提到JenkinsFile.

23
00:01:39,700 --> 00:01:41,970
JenkinsFile是个什么东西呢?

24
00:01:41,970 --> 00:01:47,675
我们可以认为JenkinsFile是它的流水线默认的一个文件名叫JenkinsFile。

25
00:01:48,100 --> 00:01:50,850
这个J是大写的。

26
00:01:51,302 --> 00:01:55,350
这个文件通常会存储在代码仓库的根目录下

27
00:01:55,628 --> 00:02:00,090
那让我们看一下流水线脚本，它是什么样子的。

28
00:02:01,150 --> 00:02:06,075
大体是分为两类：一个是脚本式，另外一个是声明式。

29
00:02:07,530 --> 00:02:12,780
我们从字面意思上可以大致猜到它是个什么样子的脚本

30
00:02:12,781 --> 00:02:15,390
可能大部分人都见过

31
00:02:16,860 --> 00:02:18,090
可能大部分人都写过

32
00:02:18,091 --> 00:02:21,000
至少是见过shell脚本

33
00:02:21,001 --> 00:02:24,330
就是一行一行有代码逻辑

34
00:02:24,331 --> 00:02:28,290
接着循环条件判断等等

35
00:02:28,291 --> 00:02:30,480
那么它的脚本也是这样的

36
00:02:31,500 --> 00:02:33,000
这我贴了一个脚本

37
00:02:33,001 --> 00:02:35,460
是语法的基本结构

38
00:02:35,461 --> 00:02:37,110
最外层是一个node

39
00:02:37,111 --> 00:02:39,090
然后里面是一个stage

40
00:02:39,091 --> 00:02:41,070
然后再写代码

41
00:02:41,070 --> 00:02:43,739
这段代码就跟java代码非常相似了

42
00:02:44,790 --> 00:02:48,050
但实际上我们也可以没有node，没有stage.

43
00:02:48,301 --> 00:02:50,370
直接这样写也可以

44
00:02:50,370 --> 00:02:54,301
换句话说，groovy怎么写，它就可以怎么写

45
00:02:54,301 --> 00:02:56,160
它就会解析groovy

46
00:02:56,161 --> 00:02:57,180
这是脚本式的(此处“声明”是口误)

47
00:03:00,210 --> 00:03:01,590
这个是脚本式的语法

48
00:03:03,690 --> 00:03:05,460
那么什么时候用的node呢

49
00:03:07,410 --> 00:03:09,570
我这是先点一下

50
00:03:09,571 --> 00:03:12,180
就是node代表一个节点

51
00:03:12,181 --> 00:03:17,101
那么这个节点就是说它会涉及到一些存储啊,计算资源.

52
00:03:17,911 --> 00:03:23,731
因此,如果你这里面的逻辑，不会涉及到任何文件的读写。

53
00:03:23,731 --> 00:03:27,930
那么你就可以不止一个node，它实际上会在master上运行

54
00:03:27,930 --> 00:03:30,870
但如果你要读写文件，它都必须落盘

55
00:03:30,872 --> 00:03:34,171
因此它必须选一个node

56
00:03:34,171 --> 00:03:35,940
应该是node{}，然后一个名称，我们先不讲这么细节

57
00:03:38,220 --> 00:03:41,250
接下来另一个类型是声明式的语法

58
00:03:41,251 --> 00:03:44,250
这也是我们比较推荐的写法

59
00:03:44,250 --> 00:03:47,790
声明式的语法，结构上稍微复杂一点

60
00:03:47,791 --> 00:03:49,980
但是看起来会更加清晰

61
00:03:49,982 --> 00:03:57,180
尤其说，当你的这个脚本变大变复杂之后，声明式有很大的优势

62
00:03:57,180 --> 00:04:02,130
脚本式会看起来很乱，难以维护

63
00:04:02,131 --> 00:04:06,780
那么声明式的语法结构大致是这样子的，最外层是一个pipeline

64
00:04:08,040 --> 00:04:10,680
然后这有一个Agent

65
00:04:10,681 --> 00:04:15,630
也就是我们这个页面上所谓的sections

66
00:04:15,631 --> 00:04:21,840
然后这里面有个stages，stage，那么stage它会有个名称

67
00:04:21,841 --> 00:04:30,090
这个名称主要是用在它的一些运行时的一些数据，以及它的图形化怎么展示上

68
00:04:30,091 --> 00:04:31,350
然后steps

69
00:04:31,351 --> 00:04:36,000
那么我自己在学的时候就发现有一个很奇怪的东西

70
00:04:36,002 --> 00:04:40,775
前面有stages里面有stage，这里有个steps，为什么没有step呢？

71
00:04:43,080 --> 00:04:44,850
我们可以这样认为

72
00:04:44,850 --> 00:04:48,599
steps里面的每一行每一句，都是一个step。

73
00:04:49,800 --> 00:04:52,140
例如，echo它就是一个step

74
00:04:53,300 --> 00:04:57,810
echo也就是说打印一句话，就跟shell里的echo是一样的

75
00:04:59,075 --> 00:05:06,480
然后script,script是一个比较特殊和兼容性的一个step

76
00:05:09,120 --> 00:05:10,740
哪里特殊呢

77
00:05:10,741 --> 00:05:14,520
我们这里的声明式语法结构

78
00:05:14,520 --> 00:05:21,750
jenkins它规定这个声明式：声明，就是一条一条声明。

79
00:05:22,051 --> 00:05:24,720
比如说stages就是一个声明

80
00:05:24,720 --> 00:05:28,020
这也是一个声明，这也是个声明。

81
00:05:28,021 --> 00:05:29,490
声明它就是说没有逻辑

82
00:05:30,900 --> 00:05:32,640
没有if-else,没有循环

83
00:05:34,075 --> 00:05:41,100
因此，我们声明式的语法，默认它是一个不能定义变量

84
00:05:41,101 --> 00:05:44,880
不能用if-else,不能用循环这样的东西

85
00:05:46,740 --> 00:05:52,650
但是有些情况你还是要做一些判断，做一些循环，那怎么办呢

86
00:05:52,650 --> 00:05:57,031
如果你想声明变量，或者做循环，做if-else

87
00:05:57,031 --> 00:06:00,750
那么你把你的这个代码块，用script把它包起来

88
00:06:02,300 --> 00:06:07,770
这就是一种声明式可以兼容脚本式语法的一种做法

89
00:06:08,750 --> 00:06:11,100
因此，从这个点上来讲

90
00:06:11,100 --> 00:06:15,150
你脚本式能干的事情，声明式应该是都可以干了

91
00:06:16,200 --> 00:06:18,450
所以我们是推荐这个声明

92
00:06:21,120 --> 00:06:23,130
OK我们再详细的看一下

93
00:06:23,131 --> 00:06:25,980
声明式的语法结构是怎么样子的

94
00:06:25,981 --> 00:06:27,930
我们看下官方的文档

95
00:06:29,490 --> 00:06:31,680
先大致浏览一下这个目录

96
00:06:32,910 --> 00:06:36,075
声明式的语法呢，有几个sections

97
00:06:36,500 --> 00:06:38,581
第一个是agent

98
00:06:38,581 --> 00:06:43,980
agent，它就是来定义你的流水线在哪个节点上运行

99
00:06:45,180 --> 00:06:47,250
我再稍微再提醒一下大家

100
00:06:47,250 --> 00:06:55,440
在社区里面，我们已经不再叫slave，全部叫agent
中文可以叫节点或者计算节点

101
00:06:55,875 --> 00:06:58,450
下一个是post

102
00:06:58,450 --> 00:07:03,180
post的意思是说，我们整个流水线执行完了之后

103
00:07:03,181 --> 00:07:07,080
希望有一些善后的一些事情

104
00:07:07,081 --> 00:07:13,116
比如说发个邮件通知一下你，这个流水线是成功还是失败了。

105
00:07:13,621 --> 00:07:16,650
或者是做一下归档等等其它的东西

106
00:07:16,651 --> 00:07:20,700
当然，这个post有很多的不同阶段

107
00:07:20,700 --> 00:07:26,250
包括说，我只要执行完了流水线就回调一下

108
00:07:26,251 --> 00:07:30,575
或者说我成功了才回调或者失败了才回调等等其它的

109
00:07:31,560 --> 00:07:33,690
stage这个就很清晰了

110
00:07:33,691 --> 00:07:36,180
就是我有哪些阶段

111
00:07:36,181 --> 00:07:40,200
第一个在忙clone，第二个去构建代码

112
00:07:40,201 --> 00:07:43,525
第三个代码打个包，打个镜像，等等

113
00:07:43,861 --> 00:07:47,430
steps也是很清晰的,就是说把一些指令都包起来

114
00:07:48,325 --> 00:07:55,175
实际上，这个agent它有很多的写法

115
00:07:56,375 --> 00:08:00,060
它可以有很多的表现形式

116
00:08:00,061 --> 00:08:04,710
例如这个any，any的意思就是我“无所谓”

117
00:08:04,711 --> 00:08:06,960
我在什么阶段上都可以运行

118
00:08:06,961 --> 00:08:08,970
比如说，echo这样的指令

119
00:08:08,971 --> 00:08:12,631
它其实不分什么机器的，linux/mac无所谓

120
00:08:14,275 --> 00:08:20,765
还有none,none的话就是说我“没有一个节点”

121
00:08:22,440 --> 00:08:25,320
为什么会有“没有一个节点”的情况呢

122
00:08:25,322 --> 00:08:33,675
是因为我们的这个agent，除了最上面

123
00:08:34,620 --> 00:08:36,480
这是我们这里的例子

124
00:08:36,481 --> 00:08:39,750
我除了最外面可以定一个agent

125
00:08:39,751 --> 00:08:44,400
在每一个stage，也可以给它定一个agent

126
00:08:44,400 --> 00:08:51,504
相当于说，如果我有3个stage，那么3个stage可能跑在不同的节点上

127
00:08:52,675 --> 00:08:57,674
比如说我有个代码想在linux编译一下

128
00:08:57,674 --> 00:09:02,610
想在mac下编译一下，在windows下编译一下

129
00:09:02,611 --> 00:09:04,410
但是我又不想交叉编译

130
00:09:04,410 --> 00:09:10,320
那么，我有真实的一些机器，就可以让它跑在不同的操作系统上去编译

131
00:09:12,870 --> 00:09:17,844
所以说呢，这最外面它就可以写成一个none，然后在每个stage里面去写

132
00:09:18,725 --> 00:09:25,357
换句话说，如果我这写的是none，那里面就必须指定一个节点

133
00:09:27,030 --> 00:09:31,500
就是外面指定，在里面就可以不指定。
如果外面没有指定的，里面必须指定

